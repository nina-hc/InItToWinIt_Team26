package catan;// --------------------------------------------------------
// Code generated by Papyrus Java
// --------------------------------------------------------

import java.util.*;


/************************************************************/
/**
 * Class to manage a players resources
 * 
 * @author Nina Hay Cooper February 13th 2026
 */
public class ResourceHand {
	/**
	 * Map to store resources Key is the resource type and value is the amount they
	 * have of the resource
	 */
	private final Map<ResourceType, Integer> resources;

	/*------Constructor-----*/
	public ResourceHand() {
		/* A map for enums, the enum being resource type */
		resources = new EnumMap<>(ResourceType.class);
		/* Using a for each loop to set up resources to be 0 at the start */
		for (ResourceType type : ResourceType.values()) {
			//excluding the desert
			if(type != ResourceType.DESERT) {
				resources.put(type, 0);// value of 0 in each key
			}
		}
	}

	/**
	 * Add resources of a specific type
	 * 
	 * @param type   type of resource to add
	 * @param amount amount of resources to add
	 */

	public void addResource(ResourceType type, int amount) {
		if (amount <= 0) {
			throw new IllegalArgumentException("Error: Negative values cannot be added");
		}
		//ignoring the desert as you don't get a resource
		if(type == ResourceType.DESERT) {
			throw new IllegalArgumentException("Error: Resources are not gained from the desert.");
		}
		// map method to add value to the value in map
		resources.put(type, (resources.get(type) + amount));// getting the current amount in there and adding the amount
															// and that's what's going in there.

	}

	/*for the robber*/
	public void removeResource(ResourceType type, int amount) {
		if (amount <= 0) {
			throw new IllegalArgumentException("Error: Negative values cannot be removed");
		}
		if(type == ResourceType.DESERT) {
			throw new IllegalArgumentException("Error: There are no resources from the desert.");
		}
		//otherwise remove the amount
		int currentAmount = resources.get(type);
		if(currentAmount < amount) {
			throw new IllegalArgumentException("Error: you cannot remove more resources than the player has.");
			//alternatively this could be implemented to remove the max rather than be an error
		}
		//subtract the current amount by the amount removed and place that as the new value
		resources.put(type,(currentAmount - amount));
	}

	/**
	 * Getter for a specific resource type
	 * 
	 * @param type resource type to get
	 * @return the number of resources
	 */
	public int getResource(ResourceType type) {
		return resources.get(type);
	}

	/**
	 * Checking if the player has enough of a one specific resource
	 * 
	 * @param type   type of resources
	 * @param amount amount needed
	 * @return true if they have the amount needed, false otherwise
	 */
	public boolean hasResource(ResourceType type, int amount) {
		return resources.get(type) >= amount;
	}

	/*--Checking if the player can build something--*/

	/**
	 * can they afford a road
	 * 
	 * @return true if they can afford a road
	 */
	public boolean canBuyRoad() {
		return (hasResource(ResourceType.LUMBER, 1) && hasResource(ResourceType.BRICK, 1));
	}

	/**
	 * can they afford a settlement
	 * 
	 * @return true if they can
	 */
	public boolean canBuySettlement() {
		return (hasResource(ResourceType.BRICK, 1) && hasResource(ResourceType.LUMBER, 1)
				&& hasResource(ResourceType.WOOL, 1) && hasResource(ResourceType.GRAIN, 1));
	}

	/**
	 * can they afford a city
	 * 
	 * @return true if they can
	 */
	public boolean canBuyCity() {
		return (hasResource(ResourceType.GRAIN, 2) && hasResource(ResourceType.ORE, 3));
	}

	/**
	 * Pay for the build Pays for the builds by subtracting the building costs
	 */
	public void payForRoad(Bank bank) {
		if (!canBuyRoad()) {
			throw new IllegalArgumentException("Error: Player does not have enough resources to buy a road");
		}
		/*take from the player*/
		resources.put(ResourceType.LUMBER, (resources.get(ResourceType.LUMBER) - 1));
		resources.put(ResourceType.BRICK, (resources.get(ResourceType.BRICK) - 1));
		/*give it back to the bank*/
		bank.resourceDeposit(ResourceType.LUMBER,1);
		bank.resourceDeposit(ResourceType.BRICK,1);
	}

	public void payForSettlement(Bank bank) {
		if (!canBuySettlement()) {
			throw new IllegalArgumentException("Error: Player does not have enough resources to buy a settlement");
		}
		resources.put(ResourceType.LUMBER, (resources.get(ResourceType.LUMBER) - 1));
		resources.put(ResourceType.BRICK, (resources.get(ResourceType.BRICK) - 1));
		resources.put(ResourceType.WOOL, (resources.get(ResourceType.WOOL) - 1));
		resources.put(ResourceType.GRAIN, (resources.get(ResourceType.GRAIN) - 1));

		//deposit resources back into the bank
		bank.resourceDeposit(ResourceType.LUMBER,1);
		bank.resourceDeposit(ResourceType.BRICK,1);
		bank.resourceDeposit(ResourceType.WOOL,1);
		bank.resourceDeposit(ResourceType.GRAIN,1);
	}

	public void payForCity(Bank bank) {
		if (!canBuyCity()) {
			throw new IllegalArgumentException("Error: Player does not have enough resources to buy a city");
		}
		resources.put(ResourceType.ORE, (resources.get(ResourceType.ORE) - 3));
		resources.put(ResourceType.GRAIN, (resources.get(ResourceType.GRAIN) - 2));

		//deposit resource back to bank
		bank.resourceDeposit(ResourceType.ORE,3);
		bank.resourceDeposit(ResourceType.GRAIN,2);
	}

	/**
	 * get the player's total amount of resources For the 7 cards check
	 * 
	 * @return total number of cards
	 */
	public int totalPlayerCard() {
		int total = 0;
		// looping through values to add up
		for (int amount : resources.values()) {
			total += amount;
		}
		return total;
	}

    /**
     * Discard a given number of resources at random (for 7-card rule)
     * @param count number of cards to discard
     */
    public void discardRandom(int count) {
        if (count <= 0) return;

        List<ResourceType> typesWithCards = new ArrayList<>();
        for (Map.Entry<ResourceType, Integer> entry : resources.entrySet()) {
            for (int i = 0; i < entry.getValue(); i++) {
                typesWithCards.add(entry.getKey());
            }
        }

        if (count > typesWithCards.size()) {
            throw new IllegalArgumentException("Cannot discard more cards than the player has.");
        }

        Random rand = new Random();
        for (int i = 0; i < count; i++) {
            int index = rand.nextInt(typesWithCards.size());
            ResourceType selected = typesWithCards.remove(index); // remove from list
            resources.put(selected, resources.get(selected) - 1); // remove from hand
        }
    }



	/**
	 * TO String Method
	 * 
	 */
	public String toString() {
		return String.format("Lumber:%d Brick:%d Wool:%d Grain:%d Ore:%d", resources.get(ResourceType.LUMBER),
				resources.get(ResourceType.BRICK), resources.get(ResourceType.WOOL), resources.get(ResourceType.GRAIN),
				resources.get(ResourceType.ORE));
	}
}
